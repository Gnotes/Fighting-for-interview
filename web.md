# Web

<details>
<summary>浏览器多个标签之间共享数据和通信</summary>

- localstorge

```
localstorage是浏览器多个标签共用的存储空间，所以可以用来实现多标签之间的通信
```

类比： *`sessionStorage` 是会话级的存储空间，每个标签页都是单独的*，**不能用于共享数据**

- cookie

```
由于 Cookies 是在同域可读的，所以在页面 B 改变 Cookies 的值，页面 A 自然是可以拿到的
```

- SharedWorker

```
普通的 webworker 直接使用new Worker()即可创建，这种webworker是当前页面专有的

然后还有种共享worker(SharedWorker)，这种是可以多个标签页、iframe共同使用的，SharedWorker可以被多个window共同使用，但必须保证这些标签页都是同源的(相同的协议，主机和端口号)
```

#### 参考

- [简书](https://www.jianshu.com/p/5f0e6d8fd36a)

</details>

<details>
<summary>WebSocket通讯</summary>

```
WebSocket是HTML5新增的协议，它的目的是在服务器和浏览器之间建立一个不受限的双向通信的通道，如: 服务器可以在任意时刻发送消息给浏览器  
```

#### 特点

- 建立在 TCP 协议之上，服务器端的实现比较容易。
- 与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。
- 数据格式比较轻量，性能开销小，通信高效。
- 可以发送文本，也可以发送二进制数据。
- 没有同源限制，客户端可以与任意服务器通信。
- 协议标识符是ws（如果加密，则为wss），服务器网址就是 URL。

其他实现方式：  

1. 轮询  
2. [Comet](https://www.cnblogs.com/imstudy/p/5696033.html)
    > 基于HTTP长连接的Web端实时通信技术，Comet本质上也是轮询，但是在没有消息的情况下，服务器先拖一段时间，等到有消息了再回复,这个机制暂时地解决了实时性问题，但是它带来了新的问题：以多线程模式运行的服务器会让大部分线程大部分时间都处于挂起状态，极大地浪费服务器资源。另外，一个HTTP连接在长时间没有数据传输的情况下，链路上的任何一个网关都可能关闭这个连接，而网关是我们不可控的，这就要求Comet连接必须定期发一些ping数据表示连接“正常工作”


#### 参考

- [简书](https://www.jianshu.com/p/5f0e6d8fd36a)
- [Comet技术详解：基于HTTP长连接的Web端实时通信技术](https://www.cnblogs.com/imstudy/p/5696033.html)

</details>

<details>
<summary>Web 性能优化</summary>

#### 网页优化

- 减少http请求次数
    1) 捆绑文件： 将多个文件打包成一个文件
    2) Css 雪碧图：多个图片拼接成一个图片，通过定位显示
    3) 内联图片：base64内联在网页或JS中
- 减少DNS查询次数
    > DNS查询也消耗响应时间，如果我们的网页内容来自各个不同的domain (比如嵌入了开放广告，引用了外部图片或脚本)，那么客户端首次解析这些domain也需要消耗一定的时间。DNS查询结果缓存在本地系统和浏览器中一段时间，所以DNS查询一般是对首次访问响应速度有所影响
- 避免页面跳转：由于页面跳转是 `再次` 发起请求，从而获取数据，因此页面跳转也是会影响加载速度
- 数据缓存：通用数据缓存
- 延迟加载
- 提前加载
- 减少DOM元素数量
    > 元素过多对网页的加载和脚本的执行都是沉重的负担
- 根据域名划分内容
    > 浏览器一般对同一个域的下载连接数有所限制，按照域名划分下载内容可以浏览器增大并行下载连接，但是注意控制域名使用在2-4个之间，不然dns查询也是个问题
- 减少iframe数量
    > 即使iframe内容为空也消耗加载时间,会阻止页面加载

#### 服务端优化

- 使用CDN
- 添加Expires 或Cache-Control报文头
    1) 静态内容添加Expires，将静态内容设为永不过期
    2) 动态内容应用合适的Cache-Control，让浏览器根据条件来发送请求
- Gzip压缩传输文件
- 配置ETags：未更改缓存
- Get请求
    > POST的时候分成两步，先发header，然后发送数据。而GET却可以用一个TCP报文完成请求。另外GET从语义上来讲是去服务器取数据，而POST则是向服务器发送数据，所以我们使请求数据的时候尽量通过GET来完成

#### Cookie

- 减少Cookie大小

#### CSS

- 将样式表置顶
    > 经样式表(css)放在网页的HEAD中会让网页显得加载速度更快，因为这样做可以使浏览器逐步加载已将下载的网页内容。这对内容比较多的网页尤其重要，用户不用一直等待在一个白屏上，而是可以先看已经下载的内容。

    > 如果将样式表放在底部，浏览器会拒绝渲染已经下载的网页，因为大多数浏览器在实现时都努力避免重绘
- 用<link>代替@import
- 避免使用Filters滤镜
    > 滤镜的使用会导致图片在下载的时候阻塞网页绘制，另外使用这种滤镜会导致内存使用量的问题

#### Javascript

- 将脚本置底
- 使用外部Javascirpt和CSS文件
- 精简Javascript和CSS
- 减少DOM访问
- 使用智能事件处理
    > 参考 JavaScript 事件委托

#### 图片

- 不要在HTML中缩放图片
    > 如果你需要小图片，就直接使用小图片
- 使用小且可缓存的favicon.ico
    > 网站图标文件favicon.ico，不管你服务器有还是没有，浏览器都会去尝试请求这个图标 (1) 确保文件存在； (2) 文件尽量小，最好小于1k; (3) 设置一个长的过期时间

#### 参考

- [毫秒必争，前端网页性能最佳实践](http://www.cnblogs.com/developersupport/p/webpage-performance-best-practices.html)

</details>

<details>
<summary>前端路由原理</summary>

- 什么是路由

> 路由是根据不同的 url 地址展示不同的内容或页面； 
　　 
- 什么是前端路由
　　
> 前端路由就是把不同路由对应不同的内容或页面的任务交给前端来做（传统的项目是服务端根据 url 的不同，返回不同的页面实现的）；

- 什么是后端路由

> 通过用户请求的url导航到具体的html页面；每跳转到不同的url，都重新访问服务端，然后服务端返回页面，页面也可以是服务端获取数据，然后和模板组合，返回HTML，也可以是直接返回模板HTML，然后由前端js再去请求数据，使用前端模板和数据进行组合，生成想要的HTML。

- 前后端路由优缺点对比

    优点：
    1) 从性能和用户体验的层面来比较，后端路由每次访问一个新页面的时候都要向服务器发送请求，然后服务器再响应请求，这个过程肯定会有延迟。而前端路由在访问一个新页面的时候仅仅是变换了一下路径而已，没有了网络延迟，对于用户体验来说会有相当大的提升。 
    2) 在某些场合中，用ajax请求，可以让页面无刷新，页面变了但url没有变化，用户就不能复制到想要的地址，用前端路由做单页面网页就很好的解决了这个问题。 

    缺点： 
    1) 使用浏览器的前进，后退键的时候会重新发送请求，没有合理地利用缓存。

- 前端路由的两种实现原理

    1) History API 
    > 利用H5两个新增的API history.pushState 和 history.replaceState； 
缺点:不支持IE9及以下,无法做IE9的适配，所以基础智能平台未使用这种实现模式,推荐使用hash。 

    2) hash
    > 根据监听哈希变化触发的事件 —— hashchange 事件；
 
#### 参考

- [前端路由的原理](https://blog.csdn.net/wangxinxin1992816/article/details/79305564)
- [前端路由的两种实现原理](https://segmentfault.com/a/1190000007238999)

</details>